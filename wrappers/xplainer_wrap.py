import pickle
from xgboost import XGBClassifier, Booster
import numpy as np
import pandas as pd

# The idea is to extract information from the pickle file generated by xplainer module (by Alexey)

class Xplainer_wrap():

    
        
    def __init__(self, filename):

        self.filename = filename

        print("loading model from ", self.filename)
        self.clf = XGBClassifier()
        self.clf = self.pickle_load_file(self.filename)


        datafile = self.form_datefile_name(self.filename)
        print("loading data from ", datafile)
        loaded_data = self.pickle_load_file(datafile)

        self.dataObj = self.DataObj(loaded_data)

        predict_old = self.clf.predict
        self.clf.predict = lambda x: predict_old(self.transform(np.array(x))).astype(int)

        
        

    def pickle_load_file(self, filename):
        try:
            f =  open(filename, "rb")
            data = pickle.load(f)
            f.close()
            return data
        except:
            print("Cannot load from file", filename)
            exit()

    def form_datefile_name(self, modfile):
        data_suffix =  '.splitdata.pkl'
        return  modfile + data_suffix

    def transform(self, x):
            if(len(x) == 0):
                return x
            if (len(x.shape) == 1):
                x = np.expand_dims(x, axis=0)
            if (self.dataObj._use_categorical):
                assert(self.dataObj._encoder != [])
                tx = []
                for i in range(self.dataObj._nb_features):
                    self.dataObj._encoder[i].drop = None
                    if (i in self.dataObj._categorical_features):
                        tx_aux = self.dataObj._encoder[i].transform(x[:,[i]])
                        tx_aux = np.vstack(tx_aux)
                        tx.append(tx_aux)
                    else:
                        tx.append(x[:,[i]])
                tx = np.hstack(tx)
                return tx
            else:
                return x


    class DataObj():

        def __init__(self, loaded_data):
            X = loaded_data["X"]
            Y = loaded_data["Y"]
            X_train = loaded_data["X_train"]
            X_test = loaded_data["X_test"]
            Y_train = loaded_data["Y_train"]
            Y_test = loaded_data["Y_test"]
            self.attributes = loaded_data["feature_names"]
            target_domain = loaded_data["target_name"]
            num_class = loaded_data["num_class"]
            assert num_class == 2, "Should handle only two classes"
            self._nb_features = len(self.attributes)
            self._categorical_features = loaded_data["categorical_features"]
            categorical_names = loaded_data["categorical_names"]
            self._encoder = loaded_data["encoder"]
            self._use_categorical = loaded_data["use_categorical"]

            self.categorical_attribute_domain_info = {}
            self.Boolean_attributes = []
            self.categorical_attributes = []
            self.continuous_attributes = []
            self.attribute_type = {}

            # need to complete it..
            self.real_attribute_domain_info = {}


            for idx in range(self._nb_features):
                if(idx in categorical_names):
                    categorical_names[idx] = list(map(int, categorical_names[idx]))
                    if(len(categorical_names[idx]) == 2):
                        assert 0 in categorical_names[idx] and 1 in categorical_names[idx]
                        self.Boolean_attributes.append(self.attributes[idx])
                        self.attribute_type[self.attributes[idx]] = "Bool"

                    else:
                        self.categorical_attribute_domain_info[self.attributes[idx]] = categorical_names[idx]
                        self.categorical_attributes.append(self.attributes[idx])
                        self.attribute_type[self.attributes[idx]] = "Categorical"

                else:
                    self.continuous_attributes.append(self.attributes[idx])
                    self.attribute_type[self.attributes[idx]] = "Real"
            


            self.target = 'target'
            self.df = pd.DataFrame(data=X, columns=self.attributes)
            self.df[self.target] = Y

            self.X_train = pd.DataFrame(data=X_train, columns=self.attributes)
            self.y_train = pd.DataFrame(data=Y_train, columns=[self.target])

            self.X_test = pd.DataFrame(data=X_test, columns=self.attributes)
            self.y_test = pd.DataFrame(data=Y_test, columns=[self.target])
            